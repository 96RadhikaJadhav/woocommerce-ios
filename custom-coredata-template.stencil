// Generated using SwiftGen â€” https://github.com/SwiftGen/SwiftGen

import Foundation

{% set accessModifier %}{% if param.publicAccess %}public{% else %}internal{% endif %}{% endset %}

{% for model in models %}
  {# {{param.entityName}}
  {{model}} #}
  {% for name, entity in model.entities %}
    {% if entity.name == param.entityName %}
      {% set superclass %}{{ model.entities[entity.superEntity].className|default:"Decodable" }}{% endset %}
      {% set entityClassName %}{{ entity.className|default:"NSManagedObject" }}{% endset %}
/// Represents a {{ entity.name }} entity.
///
      {% if entityClassName|contains:"." %}
      // Warning: '{{ entityClassName }}' cannot be a valid type name, skipping code generation.
      
      {% else %}
      {% if param.generateObjcName %}
      @objc({{ entityClassName }})
      {% endif %}
{{ accessModifier }} class {{ entityClassName }}: {{ superclass }} {
        {% set override %}{% if superclass != "NSManagedObject" %}override {% endif %}{% endset %}
      
  {% for attribute in entity.attributes %}
  {% if attribute.usesScalarValueType and attribute.isOptional %}
  {{ accessModifier }} var {{ attribute.name }}: {{ attribute.typeName }}? {
    get {
      let key = "{{ attribute.name }}"
      willAccessValue(forKey: key)
      defer { didAccessValue(forKey: key) }

      return primitiveValue(forKey: key) as? {{ attribute.typeName }}
    }
    set {
      let key = "{{ attribute.name }}"
      willChangeValue(forKey: key)
      defer { didChangeValue(forKey: key) }

      setPrimitiveValue(newValue, forKey: key)
    }
  }
  {% else %}
    {{ accessModifier }} let {{ attribute.name }}: {{ attribute.typeName }}{% if attribute.isOptional %}?{% endif %}
  {% endif %}
  {% endfor %}

    /// {{ entity.name }} initializer.
    ///
  {% for attribute in entity.attributes %}
    {% if forloop.first %}
    public init({{ attribute.name }}: {{ attribute.typeName }}{% if attribute.isOptional %}?{% endif %},
    {% elif forloop.last %}
                {{ attribute.name }}: {{ attribute.typeName }}{% if attribute.isOptional %}?{% endif %}) {
    {% else %}
                {{ attribute.name }}: {{ attribute.typeName }}{% if attribute.isOptional %}?{% endif %},
    {% endif %}
  {% endfor %}
    {% for attribute in entity.attributes %}
        self.{{ attribute.name }} = {{ attribute.name }}
    {% endfor %}
    }

    /// Public initializer for {{ entity.name }}.
    ///
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        {% for attribute in entity.attributes %}
        {% if attribute.isOptional %}
        let {{ attribute.name }} = try container.decodeIfPresent({{ attribute.typeName }}.self, forKey: .{{ attribute.name }})
        {% else %}
        let {{ attribute.name }} = try container.decode({{ attribute.typeName }}.self, forKey: .{{ attribute.name }})
        {% endif %}
        {% endfor %}

        {% for attribute in entity.attributes %}
        {% if forloop.first %}
        self.init({{ attribute.name }}: {{ attribute.name }},
        {% elif forloop.last %}
                  {{ attribute.name }}: {{ attribute.name }})
        {% else %}
                  {{ attribute.name }}: {{ attribute.name }},
        {% endif %}
        {% endfor %}
    }
        {# TODO: delete #}
        {% for relationship in entity.relationships %}
        {% if relationship.isToMany %}
        {{ accessModifier }} let {{ relationship.name }}: {% if relationship.isOrdered %}NSOrderedSet{% else %}Set<{{ model.entities[relationship.destinationEntity].className|default:"NSManagedObject" }}>{% endif %}{% if relationship.isOptional %}?{% endif %}
        {% else %}
        {{ accessModifier }} let {{ relationship.name }}: {{ model.entities[relationship.destinationEntity].className|default:"NSManagedObject" }}{% if relationship.isOptional %}?{% endif %}
        {% endif %}
        {% endfor %}
        {% for fetchedProperty in entity.fetchedProperties %}
        {{ accessModifier }} let {{ fetchedProperty.name }}: [{{ fetchedProperty.fetchRequest.entity }}]
        {% endfor %}
}


/// Defines all of the {{ entity.name }} CodingKeys
///
private extension {{ entity.name }} {
    enum CodingKeys: String, CodingKey {
        {% for attribute in entity.attributes %}
        case {{ attribute.name }}
        {% endfor %}
    }
}


// MARK: - Equatable Conformance
//
extension {{ entity.name }}: Equatable {
    public static func == (lhs: {{ entity.name }}, rhs: {{ entity.name }}) -> Bool {
        {% for attribute in entity.attributes %}
          {% if forloop.first %}
        return lhs.{{ attribute.name }} == rhs.{{ attribute.name }}
          {% else %}
            lhs.{{ attribute.name }} == rhs.{{ attribute.name }}
          {% endif %}
        {% endfor %}
    }
}

      
      {% for relationship in entity.relationships where relationship.isToMany %}
      {% set destinationEntityClassName %}{{ model.entities[relationship.destinationEntity].className|default:"NSManagedObject" }}{% endset %}
      {% set collectionClassName %}{% if relationship.isOrdered %}NSOrderedSet{% else %}Set<{{ destinationEntityClassName }}>{% endif %}{% endset %}
      {% set relationshipName %}{{ relationship.name | upperFirstLetter }}{% endset %}
      // MARK: Relationship {{ relationshipName }}
      
      extension {{ entityClassName }} {
        {% if relationship.isOrdered %}
        @objc(insertObject:in{{ relationshipName }}AtIndex:)
        @NSManaged public func insertInto{{ relationshipName }}(_ value: {{ destinationEntityClassName }}, at idx: Int)
      
        @objc(removeObjectFrom{{ relationshipName }}AtIndex:)
        @NSManaged public func removeFrom{{ relationshipName }}(at idx: Int)
      
        @objc(insert{{ relationshipName }}:atIndexes:)
        @NSManaged public func insertInto{{ relationshipName }}(_ values: [{{ destinationEntityClassName }}], at indexes: NSIndexSet)
      
        @objc(remove{{ relationshipName }}AtIndexes:)
        @NSManaged public func removeFrom{{ relationshipName }}(at indexes: NSIndexSet)
      
        @objc(replaceObjectIn{{ relationshipName }}AtIndex:withObject:)
        @NSManaged public func replace{{ relationshipName }}(at idx: Int, with value: {{ destinationEntityClassName }})
      
        @objc(replace{{ relationshipName }}AtIndexes:with{{ relationshipName }}:)
        @NSManaged public func replace{{ relationshipName }}(at indexes: NSIndexSet, with values: [{{ destinationEntityClassName }}])
      
        {% endif %}
        @objc(add{{ relationshipName }}Object:)
        @NSManaged public func addTo{{ relationshipName }}(_ value: {{ destinationEntityClassName }})
      
        @objc(remove{{ relationshipName }}Object:)
        @NSManaged public func removeFrom{{ relationshipName }}(_ value: {{ destinationEntityClassName }})
      
        @objc(add{{ relationshipName }}:)
        @NSManaged public func addTo{{ relationshipName }}(_ values: {{ collectionClassName }})
      
        @objc(remove{{ relationshipName }}:)
        @NSManaged public func removeFrom{{ relationshipName }}(_ values: {{ collectionClassName }})
      }
      
      {% endfor %}
      {% if model.fetchRequests[entity.name].count > 0 %}
      // MARK: Fetch Requests
      
      extension {{ entityClassName }} {
        {% for fetchRequest in model.fetchRequests[entity.name] %}
        {% set resultTypeName %}{% filter removeNewlines:"leading" %}
          {% if fetchRequest.resultType == "Object" %}
          {{ entityClassName }}
          {% elif fetchRequest.resultType == "Object ID" %}
          NSManagedObjectID
          {% elif fetchRequest.resultType == "Dictionary" %}
          [String: Any]
          {% endif %}
        {% endfilter %}{% endset %}
        class func fetch{{ fetchRequest.name | upperFirstLetter }}({% filter removeNewlines:"leading" %}
          managedObjectContext: NSManagedObjectContext
          {% for variableName, variableType in fetchRequest.substitutionVariables %}
          , {{ variableName | lowerFirstWord }}: {{ variableType }}
          {% endfor %}
        {% endfilter %}) throws -> [{{ resultTypeName }}] {
          guard let persistentStoreCoordinator = managedObjectContext.persistentStoreCoordinator else {
            fatalError("Managed object context has no persistent store coordinator for getting fetch request templates")
          }
          let model = persistentStoreCoordinator.managedObjectModel
          let substitutionVariables: [String: Any] = [
            {% for variableName, variableType in fetchRequest.substitutionVariables %}
            "{{ variableName }}": {{ variableName | lowerFirstWord }}
            {% empty %}
            :
            {% endfor %}
          ]
      
          guard let fetchRequest = model.fetchRequestFromTemplate(withName: "{{ fetchRequest.name }}", substitutionVariables: substitutionVariables) else {
            fatalError("No fetch request template named '{{ fetchRequest.name }}' found.")
          }
      
          guard let result = try managedObjectContext.fetch(fetchRequest) as? [{{ resultTypeName }}] else {
            fatalError("Unable to cast fetch result to correct result type.")
          }
      
          return result
        }
      
        {% endfor %}
      }
      
      {% endif %}
    {% endif %}
    {% endif %}
    {% endfor %}
{% endfor %}

